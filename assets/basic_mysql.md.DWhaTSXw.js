import{_ as t,c as r,o as l,ae as e}from"./chunks/framework.DvccZNqS.js";const n="/Innodbredlog.svg",f=JSON.parse('{"title":"Innodb是如何实现事务的","description":"","frontmatter":{},"headers":[],"relativePath":"basic/mysql.md","filePath":"basic/mysql.md","lastUpdated":1748627756000}'),d={name:"basic/mysql.md"};function i(a,o,g,s,u,h){return l(),r("div",null,o[0]||(o[0]=[e('<h1 id="innodb是如何实现事务的" tabindex="-1">Innodb是如何实现事务的 <a class="header-anchor" href="#innodb是如何实现事务的" aria-label="Permalink to &quot;Innodb是如何实现事务的&quot;">​</a></h1><p>以下是 InnoDB 通过 <strong>Buffer Pool、Log Buffer、Redo Log、Undo Log</strong> 实现事务（以 <code>UPDATE</code> 为例）的核心机制总结：</p><hr><h3 id="_1-buffer-pool-缓冲池" tabindex="-1"><strong>1. Buffer Pool（缓冲池）</strong> <a class="header-anchor" href="#_1-buffer-pool-缓冲池" aria-label="Permalink to &quot;**1. Buffer Pool（缓冲池）**&quot;">​</a></h3><ul><li><strong>作用</strong>：内存缓存区，缓存磁盘中的表/索引数据页（<code>Page</code>）。</li><li><strong>UPDATE 流程</strong>： <ol><li>从磁盘读取目标数据页到 Buffer Pool（若不存在）。</li><li>在 Buffer Pool 中修改数据页内容（此时页变为 <strong>脏页 Dirty Page</strong>）。</li><li><strong>延迟写入磁盘</strong>：脏页不会立即刷盘，由后台线程异步处理（提高性能）。</li></ol></li></ul><hr><h3 id="_2-undo-log-回滚日志" tabindex="-1"><strong>2. Undo Log（回滚日志）</strong> <a class="header-anchor" href="#_2-undo-log-回滚日志" aria-label="Permalink to &quot;**2. Undo Log（回滚日志）**&quot;">​</a></h3><ul><li><strong>作用</strong>： <ul><li><strong>回滚</strong>：记录数据修改前的值，用于事务回滚（<code>ROLLBACK</code>）。</li><li><strong>MVCC</strong>：构建多版本数据链，支持非锁定读（<code>SELECT</code> 读取旧版本）。</li></ul></li><li><strong>UPDATE 流程</strong>： <ol><li>修改数据前，将旧值写入 Undo Log（生成回滚记录）。</li><li>若事务回滚，则用 Undo Log 恢复原始数据。</li><li>事务提交后，Undo Log 不会立即删除（可能被其他事务的 MVCC 读引用）。</li></ol></li></ul><hr><h3 id="_3-redo-log-重做日志" tabindex="-1"><strong>3. Redo Log（重做日志）</strong> <a class="header-anchor" href="#_3-redo-log-重做日志" aria-label="Permalink to &quot;**3. Redo Log（重做日志）**&quot;">​</a></h3><ul><li><strong>作用</strong>：保证事务的 <strong>持久性（Durability）</strong>。 <ul><li>记录数据页的 <strong>物理修改</strong>（如 <code>Page ID</code>、偏移量、修改值）。</li><li>崩溃恢复时重放未落盘的修改。</li></ul></li><li><strong>UPDATE 流程</strong>： <ol><li>修改 Buffer Pool 数据页前，生成 Redo Log 记录。</li><li>Redo Log 暂存于内存的 <strong>Log Buffer</strong>。</li><li>事务提交时，Log Buffer 按策略刷盘（<code>innodb_flush_log_at_trx_commit</code> 控制）： <ul><li><code>=1</code>：同步写磁盘（确保不丢失）。</li><li><code>=0/2</code>：延迟写（性能更高，但可能丢失部分数据）。</li></ul></li></ol></li></ul><hr><h3 id="_4-log-buffer-日志缓冲区" tabindex="-1"><strong>4. Log Buffer（日志缓冲区）</strong> <a class="header-anchor" href="#_4-log-buffer-日志缓冲区" aria-label="Permalink to &quot;**4. Log Buffer（日志缓冲区）**&quot;">​</a></h3><ul><li><strong>作用</strong>：Redo Log 的临时内存缓冲区。</li><li><strong>UPDATE 流程</strong>： <ol><li>Redo Log 记录先写入 Log Buffer。</li><li>事务提交时触发刷盘（由参数控制策略）。</li><li>避免每次修改都写磁盘，提升性能。</li></ol></li></ul><hr><h3 id="update-操作完整流程" tabindex="-1"><strong>UPDATE 操作完整流程</strong> <a class="header-anchor" href="#update-操作完整流程" aria-label="Permalink to &quot;**UPDATE 操作完整流程**&quot;">​</a></h3><p><img src="'+n+'" alt="崩溃恢复流程图" width="800"></p><hr><h3 id="崩溃恢复机制" tabindex="-1"><strong>崩溃恢复机制</strong> <a class="header-anchor" href="#崩溃恢复机制" aria-label="Permalink to &quot;**崩溃恢复机制**&quot;">​</a></h3><ol><li><strong>Redo Log 重做</strong>： <ul><li>重放已提交事务的 Redo Log，恢复 Buffer Pool 中的脏页。</li></ul></li><li><strong>Undo Log 回滚</strong>： <ul><li>对未提交的事务，用 Undo Log 回滚修改。</li></ul></li></ol><hr><h3 id="关键设计思想" tabindex="-1"><strong>关键设计思想</strong> <a class="header-anchor" href="#关键设计思想" aria-label="Permalink to &quot;**关键设计思想**&quot;">​</a></h3><ol><li><strong>Write-Ahead Logging (WAL)</strong>：<br> Redo Log 先于数据页落盘（确保持久性）。</li><li><strong>随机写转顺序写</strong>：<br> 数据页修改（随机写） → Redo Log 追加（顺序写），大幅提升 IO 效率。</li><li><strong>异步刷脏页</strong>：<br> 事务提交只需保证 Redo Log 落盘，脏页由后台线程批量写入磁盘。</li><li><strong>两阶段提交（2PC）</strong>：<br> 与 Binlog 协作时，通过 Redo Log 的 <code>prepare</code> 和 <code>commit</code> 状态保证一致性。</li></ol><hr><h3 id="核心组件对比" tabindex="-1"><strong>核心组件对比</strong> <a class="header-anchor" href="#核心组件对比" aria-label="Permalink to &quot;**核心组件对比**&quot;">​</a></h3><table tabindex="0"><thead><tr><th>组件</th><th>作用</th><th>持久化时机</th><th>是否崩溃恢复必需</th></tr></thead><tbody><tr><td><strong>Buffer Pool</strong></td><td>缓存数据页</td><td>异步刷脏页</td><td>❌</td></tr><tr><td><strong>Log Buffer</strong></td><td>缓存 Redo Log</td><td>事务提交时控制刷盘</td><td>❌</td></tr><tr><td><strong>Redo Log</strong></td><td>保证事务持久性</td><td>事务提交时强制刷盘</td><td>✔️</td></tr><tr><td><strong>Undo Log</strong></td><td>支持回滚与 MVCC</td><td>随 Redo Log 间接持久化</td><td>✔️</td></tr></tbody></table><blockquote><p><strong>关键结论</strong>：</p><ul><li><strong>提交性能</strong>：由 Redo Log 刷盘效率决定（顺序写远快于随机写）。</li><li><strong>数据安全</strong>：事务提交后即使脏页未落盘，Redo Log 也能保证数据不丢失。</li><li><strong>回滚能力</strong>：Undo Log 使得任意时刻回滚成为可能。</li></ul></blockquote>',27)]))}const b=t(d,[["render",i]]);export{f as __pageData,b as default};
